<!doctype html>
<html lang="en">
  <head>
    
    
      
    

    
    
      
    

    
    

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MTA Buses</title>
    <meta name="description" content="Real-time MTA bus arrivals and nearby bus stops in New York City." />
    <meta name="robots" content="index,follow,max-image-preview:large" />
    <link rel="canonical" href="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;buses&#x2F;" />
    <meta name="author" content="MTA Arrivals" />
    
      <meta name="keywords" content="MTA, NYC subway, MTA trains, MTA buses, real-time arrivals, New York transit" />
    

    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="MTA" />
    <meta property="og:title" content="MTA Buses | MTA" />
    <meta property="og:description" content="Real-time MTA bus arrivals and nearby bus stops in New York City." />
    <meta property="og:url" content="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;buses&#x2F;" />
    <meta property="og:image" content="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;mta.png" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="MTA Buses | MTA" />
    <meta name="twitter:description" content="Real-time MTA bus arrivals and nearby bus stops in New York City." />
    <meta name="twitter:image" content="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;mta.png" />
    <style>
      html {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-size: 16px;
        touch-action: manipulation;
        background: var(--bg);
        min-height: 100dvh;
      }
      * {
        box-sizing: inherit;
        margin: 0;
        padding: 0;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
      :root {
        color-scheme: light dark;
        --bg: #fff;
        --text: #000;
        --text-secondary: #666;
        --border: #eee;
        --error: #d32f2f;
        --warning: #f57c00;
        --surface: rgba(0, 0, 0, 0.03);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.5;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #000;
          --text: #fff;
          --text-secondary: #999;
          --border: #333;
          --error: #ff6b6b;
          --warning: #ffb74d;
          --surface: rgba(255, 255, 255, 0.06);
        }
      }
      body {
        padding: 1.25rem;
        padding-top: max(1.25rem, env(safe-area-inset-top));
        padding-bottom: max(1.25rem, env(safe-area-inset-bottom));
        padding-left: max(1.25rem, env(safe-area-inset-left));
        padding-right: max(1.25rem, env(safe-area-inset-right));
        max-width: 37.5rem;
        margin: 0 auto;
        background: var(--bg);
        color: var(--text);
        font-size: 1.125rem;
        transition:
          background-color 0.2s,
          color 0.2s;
        min-height: 100dvh;
      }
      main {
        min-height: 0;
      }
      a {
        color: inherit;
      }
      .site-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid var(--border, #e5e5e5);
      }
      .site-title {
        font-size: 1rem;
        font-weight: 700;
        text-decoration: none;
        color: inherit;
      }
      .site-nav {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .site-nav a {
        font-size: 0.95rem;
        text-decoration: none;
        color: inherit;
        opacity: 0.8;
      }
      .site-nav a:hover,
      .site-nav a:focus-visible {
        opacity: 1;
        text-decoration: underline;
      }
      .empty-page {
        padding-top: 0.25rem;
      }
      .page-title {
        font-size: 1.375rem;
        font-weight: 600;
        margin-bottom: 0.375rem;
      }
      .page-subtitle {
        color: var(--text-secondary);
        font-size: 0.95rem;
        margin-bottom: 0.875rem;
      }
      .placeholder-box {
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: var(--surface);
        padding: 1rem;
      }
    </style>
    
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta
      name="description"
      content="Real-time MTA bus arrivals near your location. See nearby stops and the next buses coming."
    />
    <meta name="theme-color" content="#0f5da8" />
    <style>
      button {
        padding: 1rem 2.25rem;
        font-size: 1.125rem;
        font-weight: 500;
        cursor: pointer;
        border: none;
        background: #0f5da8;
        color: #fff;
        border-radius: 1.5rem;
        margin: 0 auto 1.25rem;
        display: block;
        width: 80%;
        max-width: 20rem;
        -webkit-appearance: none;
        appearance: none;
        transition: opacity 0.15s;
      }
      button:active {
        opacity: 0.8;
      }
      .station {
        margin-bottom: 1.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid var(--border);
      }
      .station:last-child {
        border-bottom: none;
      }
      .station-header {
        display: flex;
        flex-direction: column;
        gap: 0.375rem;
        margin-bottom: 0.625rem;
      }
      .station-info {
        display: flex;
        align-items: baseline;
        gap: 0.5rem;
        min-width: 0;
      }
      .station-name {
        font-size: 1.25rem;
        font-weight: 600;
      }
      .distance {
        color: var(--text-secondary);
        font-size: 0.75rem;
      }
      .station-badges {
        display: flex;
        gap: 0.25rem;
        flex-wrap: wrap;
      }
      .route-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 2rem;
        height: 2rem;
        border-radius: 999px;
        color: #fff;
        font-weight: 700;
        font-size: 0.9rem;
        padding: 0 0.5rem;
        flex-shrink: 0;
      }
      .station-badges .route-badge {
        cursor: pointer;
        transition:
          opacity 0.15s,
          transform 0.15s;
      }
      .station-badges .route-badge:active {
        transform: scale(0.95);
      }
      .station-badges .route-badge.filter-inactive {
        opacity: 0.35;
      }
      .bus-list {
        display: flex;
        flex-direction: column;
      }
      .bus {
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--border);
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 0.5rem;
        font-size: 1.05rem;
      }
      .bus:last-child {
        border-bottom: none;
      }
      .time-dest {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }
      .time-text {
        font-size: 1.1rem;
      }
      .destination {
        color: var(--text-secondary);
        font-size: 0.75rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .stops-away {
        color: var(--text-secondary);
        font-size: 0.75rem;
      }
      .loading,
      .error,
      .warning {
        color: var(--text-secondary);
      }
      .error {
        color: var(--error);
      }
      .warning {
        color: var(--warning);
        font-size: 0.95rem;
        margin-top: 0.625rem;
      }
      .key-card {
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: var(--surface);
        padding: 1rem;
        margin-bottom: 1rem;
      }
      .key-card h3 {
        font-size: 1.05rem;
        margin-bottom: 0.5rem;
      }
      .key-card p {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-bottom: 0.75rem;
      }
      .key-actions {
        display: flex;
        gap: 0.5rem;
      }
      .key-actions input {
        flex: 1;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: var(--bg);
        color: var(--text);
        font-size: 0.9rem;
        padding: 0.65rem 0.75rem;
        min-width: 0;
      }
      .key-actions button {
        width: auto;
        max-width: none;
        margin: 0;
        border-radius: 0.5rem;
        padding: 0.65rem 1rem;
        font-size: 0.9rem;
      }
      .key-link {
        display: inline-block;
        font-size: 0.85rem;
        margin-top: 0.55rem;
      }
    </style>

  </head>
  <body>
    



<header class="site-header">
  <a class="site-title" href="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;">MTA</a>
  <nav class="site-nav" aria-label="Primary">
    <a href="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;">Trains</a>
    <a href="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;buses&#x2F;">Buses</a>
    <a href="https:&#x2F;&#x2F;mta.guadarrama.us&#x2F;map&#x2F;">Map</a>
  </nav>
</header>

    <main>
    <div
      style="
        display: flex;
        gap: 0.75rem;
        justify-content: center;
        align-items: center;
        margin-bottom: 1.25rem;
      "
    >
      <button onclick="refreshBusTimes()" style="margin: 0; flex: 1">
        Refresh Times
      </button>
      <button
        onclick="refreshLocation()"
        style="
          margin: 0;
          width: 3.5rem;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          aspect-ratio: 1;
        "
        aria-label="Refresh Location"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="22"
          height="22"
          viewBox="0 0 24 24"
          fill="currentColor"
        >
          <path
            d="M12 2C12.5523 2 13 2.44772 13 3V4.06189C16.6187 4.51314 19.4869 7.38128 19.9381 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H19.9381C19.4869 16.6187 16.6187 19.4869 13 19.9381V21C13 21.5523 12.5523 22 12 22C11.4477 22 11 21.5523 11 21V19.9381C7.38128 19.4869 4.51314 16.6187 4.06189 13H3C2.44772 13 2 12.5523 2 12C2 11.4477 2.44772 11 3 11H4.06189C4.51314 7.38128 7.38128 4.51314 11 4.06189V3C11 2.44772 11.4477 2 12 2ZM12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6ZM12 9C13.6569 9 15 10.3431 15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9Z"
          />
        </svg>
      </button>
    </div>

    <div id="content"></div>

    <script>
      const KEY_STORAGE = "mta_bus_time_api_key";

      let cachedStops = null;
      let lastRefreshPromise = null;
      let lastRefreshTime = null;
      let refreshInterval = null;
      let activeFilters = {};
      let lastRenderState = null;

      function getStoredKey() {
        return (localStorage.getItem(KEY_STORAGE) || "").trim();
      }

      function setStoredKey(value) {
        localStorage.setItem(KEY_STORAGE, value.trim());
      }

      function clearStoredKey() {
        localStorage.removeItem(KEY_STORAGE);
      }

      function firstText(value) {
        if (Array.isArray(value)) return value[0] || "";
        return value || "";
      }

      function shortRoute(value) {
        let raw = firstText(value);
        if (!raw) return "";
        raw = String(raw).trim();
        if (raw.includes("_")) raw = raw.slice(raw.lastIndexOf("_") + 1);
        if (raw.includes(" ")) raw = raw.slice(raw.lastIndexOf(" ") + 1);
        return raw.trim();
      }

      function routeColor(route) {
        const id = String(route || "BUS");
        let hash = 0;
        for (let i = 0; i < id.length; i++) hash = (hash * 31 + id.charCodeAt(i)) >>> 0;
        const hue = hash % 360;
        return `hsl(${hue} 72% 42%)`;
      }

      function normalizeStopCode(stop) {
        const code = String(stop?.code || "").trim();
        if (code) return code;

        const id = String(stop?.id || "").trim();
        if (!id) return "";
        if (id.includes("_")) return id.slice(id.lastIndexOf("_") + 1);
        return id;
      }

      function haversine(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c * 1000;
      }

      function formatDistance(meters) {
        if (!Number.isFinite(meters)) return "";
        if (meters >= 1000) return `${(meters / 1000).toFixed(1)} km`;
        return `${Math.round(meters)}m`;
      }

      function formatMinutes(arrivalDate) {
        const mins = Math.round((arrivalDate.getTime() - Date.now()) / 60000);
        if (mins <= 0) return "Due";
        return `${mins} min`;
      }

      function escapeHtml(text) {
        return String(text || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function isBustimeUrl(url) {
        try {
          return new URL(url).hostname === "bustime.mta.info";
        } catch (_error) {
          return false;
        }
      }

      async function fetchJsonp(url, timeoutMs = 15000) {
        return new Promise((resolve, reject) => {
          const callbackName = `__mtaBusJsonp_${Date.now()}_${Math.random().toString(36).slice(2)}`;
          let timeoutId = null;
          const script = document.createElement("script");

          const cleanup = () => {
            if (timeoutId) clearTimeout(timeoutId);
            delete window[callbackName];
            script.remove();
          };

          window[callbackName] = (data) => {
            cleanup();
            if (typeof data?.code === "number" && data.code !== 200) {
              reject(new Error(data.text || `API error ${data.code}`));
              return;
            }
            resolve(data);
          };

          script.onerror = () => {
            cleanup();
            reject(new Error("Failed to load Bus Time JSONP response."));
          };

          const sep = url.includes("?") ? "&" : "?";
          script.src = `${url}${sep}callback=${encodeURIComponent(callbackName)}`;
          script.async = true;
          document.head.appendChild(script);

          timeoutId = setTimeout(() => {
            cleanup();
            reject(new Error("Bus Time request timed out."));
          }, timeoutMs);
        });
      }

      async function fetchJson(url) {
        if (isBustimeUrl(url)) return fetchJsonp(url);
        const res = await fetch(url, {
          headers: { Accept: "application/json" },
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (typeof data.code === "number" && data.code !== 200) {
          throw new Error(data.text || `API error ${data.code}`);
        }
        return data;
      }

      async function getCurrentPosition() {
        return new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: false,
            timeout: 12000,
            maximumAge: 0,
          });
        });
      }

      async function loadNearbyStops(apiKey) {
        const position = await getCurrentPosition();
        const userLat = position.coords.latitude;
        const userLon = position.coords.longitude;

        const params = new URLSearchParams({
          lat: String(userLat),
          lon: String(userLon),
          radius: "900",
          version: "2",
          key: apiKey,
        });

        const data = await fetchJson(
          `https://bustime.mta.info/api/where/stops-for-location.json?${params}`,
        );

        const references = data?.data?.references || {};
        const routeLookup = new Map(
          (references.routes || []).map((route) => [
            route.id,
            route.shortName || route.short_name || shortRoute(route.id),
          ]),
        );

        const stops = (data?.data?.list || [])
          .map((stop) => {
            const routes = (stop.routeIds || stop.routeIDs || [])
              .map((routeId) => routeLookup.get(routeId) || shortRoute(routeId))
              .filter(Boolean);

            return {
              id: stop.id,
              code: stop.code || normalizeStopCode(stop),
              name: stop.name,
              lat: stop.lat,
              lon: stop.lon,
              routes: [...new Set(routes)],
              dist: haversine(userLat, userLon, stop.lat, stop.lon),
            };
          })
          .filter((s) => s.name && Number.isFinite(s.lat) && Number.isFinite(s.lon))
          .sort((a, b) => a.dist - b.dist)
          .slice(0, 6);

        if (stops.length === 0) {
          throw new Error("No nearby bus stops found.");
        }

        return stops;
      }

      async function fetchStopArrivals(stop, apiKey) {
        const monitoringRef = normalizeStopCode(stop);
        if (!monitoringRef) return [];

        const params = new URLSearchParams({
          key: apiKey,
          OperatorRef: "MTA",
          MonitoringRef: monitoringRef,
          MaximumStopVisits: "10",
          version: "2",
        });

        const data = await fetchJson(
          `https://bustime.mta.info/api/siri/stop-monitoring.json?${params}`,
        );

        const deliveries =
          data?.Siri?.ServiceDelivery?.StopMonitoringDelivery || [];
        const visits = [];

        deliveries.forEach((delivery) => {
          if (Array.isArray(delivery.MonitoredStopVisit)) {
            visits.push(...delivery.MonitoredStopVisit);
          }
        });

        const now = Date.now();

        const arrivals = visits
          .map((visit) => {
            const journey = visit?.MonitoredVehicleJourney || {};
            const call = journey.MonitoredCall || {};
            const expectedTime =
              call.ExpectedArrivalTime ||
              call.AimedArrivalTime ||
              call.ExpectedDepartureTime ||
              call.AimedDepartureTime;

            const arrival = expectedTime ? new Date(expectedTime) : null;
            if (!arrival || Number.isNaN(arrival.getTime())) return null;
            if (arrival.getTime() < now - 30000) return null;

            const route =
              shortRoute(journey.PublishedLineName) ||
              shortRoute(journey.LineRef) ||
              "BUS";

            const destination =
              firstText(journey.DestinationName) ||
              shortRoute(journey.DestinationRef) ||
              "Destination unavailable";

            const stopsAway =
              call?.Extensions?.Distances?.StopsFromCall ??
              call?.Extensions?.Distances?.stopsFromCall ??
              null;

            return {
              route,
              destination,
              arrival,
              direction: String(journey.DirectionRef ?? ""),
              stopsAway,
              vehicleRef: String(journey.VehicleRef || ""),
            };
          })
          .filter(Boolean)
          .sort((a, b) => a.arrival - b.arrival);

        const seen = new Set();
        return arrivals
          .filter((a) => {
            const key = `${a.route}-${a.vehicleRef}-${a.arrival.getTime()}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          })
          .slice(0, 8);
      }

      async function fetchArrivalsForStops(stops, apiKey) {
        let failCount = 0;
        const results = await Promise.allSettled(
          stops.map((stop) => fetchStopArrivals(stop, apiKey)),
        );

        const arrivalsByStop = new Map();
        results.forEach((result, idx) => {
          const stopId = stops[idx].id;
          if (result.status === "fulfilled") {
            arrivalsByStop.set(stopId, result.value);
          } else {
            failCount++;
            console.warn("Stop monitoring failed", result.reason);
            arrivalsByStop.set(stopId, []);
          }
        });

        return { arrivalsByStop, failCount };
      }

      function renderKeyCard(message = "") {
        const content = document.getElementById("content");
        const storedKey = getStoredKey();

        content.innerHTML = `
          <div class="key-card">
            <h3>MTA Bus Time API key required</h3>
            <p>
              Bus arrivals require your Bus Time developer key. Enter it once and it will be saved on this device.
            </p>
            ${message ? `<p class="error">${escapeHtml(message)}</p>` : ""}
            <div class="key-actions">
              <input id="bus-api-key" type="password" placeholder="Paste Bus Time API key" value="${escapeHtml(storedKey)}" autocomplete="off" />
              <button id="save-bus-key" type="button">Save</button>
            </div>
            <a class="key-link" href="https://bustime.mta.info/wiki/Developers/Index" target="_blank" rel="noopener noreferrer">
              Get a free key from MTA Bus Time Developers
            </a>
          </div>
        `;

        const input = document.getElementById("bus-api-key");
        const saveButton = document.getElementById("save-bus-key");

        const save = () => {
          const value = (input?.value || "").trim();
          if (!value) {
            renderKeyCard("Please enter a valid API key.");
            return;
          }
          setStoredKey(value);
          cachedStops = null;
          load();
        };

        saveButton?.addEventListener("click", save);
        input?.addEventListener("keydown", (event) => {
          if (event.key === "Enter") save();
        });
      }

      function createArrivalRow(arrival) {
        const row = document.createElement("div");
        row.className = "bus";

        const badge = document.createElement("span");
        badge.className = "route-badge";
        badge.style.background = routeColor(arrival.route);
        badge.textContent = arrival.route;
        row.appendChild(badge);

        const timeDest = document.createElement("div");
        timeDest.className = "time-dest";

        const time = document.createElement("span");
        time.className = "time-text";
        time.textContent = formatMinutes(arrival.arrival);
        timeDest.appendChild(time);

        const destination = document.createElement("span");
        destination.className = "destination";
        destination.textContent = arrival.destination;
        timeDest.appendChild(destination);

        row.appendChild(timeDest);

        const stopsAway = document.createElement("span");
        stopsAway.className = "stops-away";
        if (Number.isFinite(arrival.stopsAway)) {
          stopsAway.textContent = `${arrival.stopsAway} stops`;
        }
        row.appendChild(stopsAway);

        return row;
      }

      function renderStopCard(stop, arrivals) {
        const stationDiv = document.createElement("div");
        stationDiv.className = "station";

        const header = document.createElement("div");
        header.className = "station-header";

        const info = document.createElement("div");
        info.className = "station-info";

        const name = document.createElement("span");
        name.className = "station-name";
        name.textContent = stop.name;
        info.appendChild(name);

        const distance = document.createElement("span");
        distance.className = "distance";
        distance.textContent = formatDistance(stop.dist);
        info.appendChild(distance);
        header.appendChild(info);

        const badges = document.createElement("div");
        badges.className = "station-badges";

        let activeFilter = activeFilters[stop.id] || null;

        (stop.routes || []).forEach((route) => {
          const badge = document.createElement("span");
          badge.className = "route-badge";
          badge.textContent = route;
          badge.style.background = routeColor(route);
          badge.dataset.route = route;

          badge.onclick = () => {
            if (activeFilter === route) {
              activeFilter = null;
              activeFilters[stop.id] = null;
            } else {
              activeFilter = route;
              activeFilters[stop.id] = route;
            }
            renderFromState();
          };

          if (activeFilter && activeFilter !== route) {
            badge.classList.add("filter-inactive");
          }

          badges.appendChild(badge);
        });

        header.appendChild(badges);
        stationDiv.appendChild(header);

        const list = document.createElement("div");
        list.className = "bus-list";

        const filtered = activeFilter
          ? arrivals.filter((a) => a.route === activeFilter)
          : arrivals;

        if (filtered.length === 0) {
          const empty = document.createElement("div");
          empty.className = "bus";
          empty.textContent = "No upcoming buses";
          list.appendChild(empty);
        } else {
          filtered.forEach((arrival) => {
            list.appendChild(createArrivalRow(arrival));
          });
        }

        stationDiv.appendChild(list);

        return stationDiv;
      }

      function renderFromState() {
        if (!lastRenderState) return;

        const content = document.getElementById("content");
        const fragment = document.createDocumentFragment();

        const timestamp = document.createElement("div");
        timestamp.style.cssText =
          "color: var(--text-secondary); font-size: 14px; margin-bottom: 20px;";
        timestamp.textContent = lastRefreshTime
          ? `Last refresh: ${lastRefreshTime.toLocaleTimeString()} Â· Auto-refresh every 30s`
          : "Auto-refresh every 30s";
        fragment.appendChild(timestamp);

        lastRenderState.stops.forEach((stop) => {
          const arrivals = lastRenderState.arrivalsByStop.get(stop.id) || [];
          fragment.appendChild(renderStopCard(stop, arrivals));
        });

        if (lastRenderState.failCount > 0) {
          const warning = document.createElement("div");
          warning.className = "warning";
          warning.textContent = `Note: ${lastRenderState.failCount} stop requests failed. Some arrivals may be missing.`;
          fragment.appendChild(warning);
        }

        content.innerHTML = "";
        content.appendChild(fragment);
      }

      async function load() {
        const content = document.getElementById("content");
        const apiKey = getStoredKey();

        if (!apiKey) {
          renderKeyCard();
          return;
        }

        content.innerHTML = '<div class="loading">Loading nearby bus stops...</div>';

        try {
          if (!cachedStops) {
            cachedStops = await loadNearbyStops(apiKey);
          }

          const arrivals = await fetchArrivalsForStops(cachedStops, apiKey);
          lastRefreshTime = new Date();
          lastRenderState = {
            stops: cachedStops,
            arrivalsByStop: arrivals.arrivalsByStop,
            failCount: arrivals.failCount,
          };
          renderFromState();
        } catch (error) {
          console.error("Bus page load failed", error);
          const message = String(error?.message || error);
          const lowerMessage = message.toLowerCase();

          if (
            message.includes("HTTP 401") ||
            message.includes("HTTP 403") ||
            lowerMessage.includes("access") ||
            lowerMessage.includes("invalid key")
          ) {
            clearStoredKey();
            cachedStops = null;
            renderKeyCard("Your API key was rejected. Please check and try again.");
            return;
          }

          if (error?.code === 1 || lowerMessage.includes("geolocation")) {
            content.innerHTML =
              '<div class="error">Location access is required to find nearby bus stops.</div>';
            return;
          }

          content.innerHTML = `<div class="error">Error: ${escapeHtml(message)}</div>`;
        }
      }

      function startRefreshInterval() {
        if (refreshInterval) clearInterval(refreshInterval);
        refreshInterval = setInterval(refreshBusTimes, 30000);
      }

      function stopRefreshInterval() {
        if (refreshInterval) {
          clearInterval(refreshInterval);
          refreshInterval = null;
        }
      }

      async function refreshBusTimes() {
        if (lastRefreshPromise) return;

        const apiKey = getStoredKey();
        if (!apiKey) {
          renderKeyCard();
          return;
        }

        if (!cachedStops) {
          await load();
          return;
        }

        try {
          lastRefreshPromise = fetchArrivalsForStops(cachedStops, apiKey);
          const arrivals = await lastRefreshPromise;

          lastRefreshTime = new Date();
          lastRenderState = {
            stops: cachedStops,
            arrivalsByStop: arrivals.arrivalsByStop,
            failCount: arrivals.failCount,
          };

          renderFromState();
        } catch (error) {
          console.error("Refresh failed", error);
          const content = document.getElementById("content");
          content.innerHTML = `<div class="error">Error: ${escapeHtml(error.message || error)}</div>`;
        } finally {
          lastRefreshPromise = null;
        }
      }

      async function refreshLocation() {
        cachedStops = null;
        activeFilters = {};
        await load();
      }

      document.addEventListener("visibilitychange", () => {
        document.hidden ? stopRefreshInterval() : startRefreshInterval();
      });

      window.addEventListener("DOMContentLoaded", () => {
        load();
        startRefreshInterval();
      });
    </script>
</main>
    <script>
      async function requestLocationPermissionOnLoad() {
        if (!("geolocation" in navigator)) return;

        try {
          if ("permissions" in navigator && navigator.permissions?.query) {
            const permissionStatus = await navigator.permissions.query({
              name: "geolocation",
            });
            if (permissionStatus.state === "granted") return;
          }
        } catch (_err) {
          // Continue and try requesting location directly.
        }

        navigator.geolocation.getCurrentPosition(
          () => {},
          () => {},
          {
            enableHighAccuracy: false,
            timeout: 10000,
            maximumAge: 0,
          },
        );
      }

      window.addEventListener("DOMContentLoaded", () => {
        requestLocationPermissionOnLoad();
      });
    </script>
  </body>
</html>
